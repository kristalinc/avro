##
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##     http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##

## Modifications by Duane Moore, Clover, Aug 2013

#if ($this.getNamespace($schema))
package $this.getNamespace($schema);
#end

@SuppressWarnings("all")
#if ($schema.getDoc())
/** $schema.getDoc() */
#end
#foreach ($annotation in $this.javaAnnotations($schema))
@$annotation
#end
public final class ${this.mangle($schema.getName())} implements android.os.Parcelable, ${this.getBasePackage()}.Validator, ${this.getBaseBasePackage()}.JSONifiable {

#if ($schema.getProp("authority"))
  public static final String AUTHORITY = "$schema.getProp("authority")";
#end

  private String jsonString = null;
  private org.json.JSONObject jsonObject = null;
  private android.os.Bundle bundle = null;
  private android.os.Bundle changeLog = null;

  /**
   * Constructs a new empty instance.
   */
  public ${this.mangle($schema.getName())}() { }

#if ($schema.getFields().size() > 0)
  /**
   * Constructs a new instance from the given JSON String.
   */
  public ${this.mangle($schema.getName())}(String json) {
    this.jsonString = json;
  }

  /**
   * Construct a new instance backed by the given JSONObject, the parameter is not copied so changes to it will be
   * reflected in this instance and vice-versa.
   */
  public ${this.mangle($schema.getName())}(org.json.JSONObject jsonObject) {
    this.jsonObject = jsonObject;
  }

  /**
   * Constructs a new instance that is a deep copy of the source instance. It does not copy the bundle or changelog.
   */
  public ${this.mangle($schema.getName())}(${this.mangle($schema.getName())} src) {
    org.json.JSONObject jsonObjectSrc = src.getJSONObject();

    try {
      // Makes a deep copy, but isn't the most performant
      this.jsonObject = new org.json.JSONObject(jsonObjectSrc.toString());
    } catch (org.json.JSONException e) {
      throw new java.lang.IllegalArgumentException(e);
    }
  }
#end

  /**
   * Returns the internal JSONObject backing this instance, the return value is not a copy so changes to it will be
   * reflected in this instance and vice-versa.
   */
  public org.json.JSONObject getJSONObject() {
    try {
      if (jsonObject == null) {
        if (jsonString != null) {
          jsonObject = (org.json.JSONObject) new org.json.JSONTokener(jsonString).nextValue();
          jsonString = null; // null this so it will be recreated if jsonObject is modified
        } else {
          jsonObject = new org.json.JSONObject();
        }
      }
    } catch (org.json.JSONException e) {
      throw new java.lang.IllegalArgumentException(e);
    }
    return jsonObject;
  }


  @Override
  public void validate() {
#foreach ($field in $schema.getFields())
#set( $validityCheck = "" )
#set( $validityCheck = $this.generateValidityCheck($field, ${this.mangle($field.name(), $schema.isError())}) )
#set( $needsValidityCheck = $validityCheck.length() > 0 )
#set( $needsRequiredCheck = ${this.isRequiredOnCreate($field)} )
#if ($needsRequiredCheck || $needsValidityCheck)
#if( !$foreach.first )

#end
    ${this.javaType($field.schema())} ${this.mangle($field.name(), $schema.isError())} = ${this.generateGetMethod($schema, $field)}();
#if ($needsRequiredCheck)
    if (${this.mangle($field.name(), $schema.isError())} == null) throw new java.lang.IllegalArgumentException("'${this.mangle($field.name())}' is required to be non-null");
#end
#if ($needsValidityCheck)
    ${this.generateValidityCheck($field, ${this.mangle($field.name(), $schema.isError())})}
#end
#end
#end
  }


#foreach ($field in $schema.getFields())
  /**
#if ($field.doc())
   * $field.doc()
#end
   * The returned object is not a copy so changes to it will be reflected in this instance and vice-versa.
#if (${this.isArray($field.schema())})
   *
   * The returned List is unmodifiable and will never contain any nulls, even if the source JSON had null entries.
#end
   */
#if (${this.isArray($field.schema())})
  public java.util.List<${this.javaType($field.schema().getElementType())}> ${this.generateGetMethod($schema, $field)}() {
    if (getJSONObject().isNull("${this.mangle($field.name(), $schema.isError())}")) {
      return null;
    }

    org.json.JSONObject elementsContainer = getJSONObject().optJSONObject("${this.mangle($field.name(), $schema.isError())}");
    org.json.JSONArray itemArray = elementsContainer.optJSONArray("elements");
    java.util.List<${this.javaType($field.schema().getElementType())}> itemList =
        new java.util.ArrayList<${this.javaType($field.schema().getElementType())}>(itemArray.length());
    for (int i = 0; i < itemArray.length(); i++) {
#if (${this.isRecord($field.schema().getElementType())})
      org.json.JSONObject obj = itemArray.optJSONObject(i);
      if (obj == null) {
        continue;
      }
      ${this.javaType($field.schema().getElementType())} item = new ${this.javaType($field.schema().getElementType())}(obj);
#elseif (${this.isEnum($field.schema().getElementType())})
      String enumString = itemArray.optString(i, null);
      if (enumString == null) {
        continue;
      }
      ${this.javaType($field.schema().getElementType())} item;
      try {
        item = ${this.javaType($field.schema().getElementType())}.valueOf(enumString);
      } catch (Exception e) {
        e.printStackTrace();
        continue;
      }
#else
      ${this.javaType($field.schema().getElementType())} item = itemArray.${this.jsonAccessor($field.schema().getElementType())}(i);
      if (item == null) {
        continue;
      }
#end
      itemList.add(item);
    }

    return java.util.Collections.unmodifiableList(itemList);
  }
#elseif (${this.isEnum($field.schema())})
  public ${this.javaType($field.schema())} ${this.generateGetMethod($schema, $field)}() {
    if (${this.generateIsNotNullMethod($schema, $field)}()) {
      try {
        return ${this.javaType($field.schema())}.valueOf(getJSONObject().optString("${this.mangle($field.name(), $schema.isError())}"));
      } catch(Exception e) {
        e.printStackTrace();
      }
    }

    return null;
  }
#elseif (${this.isRecord($field.schema())})
  public ${this.javaType($field.schema())} ${this.generateGetMethod($schema, $field)}() {
    org.json.JSONObject jsonObj = getJSONObject().${this.jsonAccessor($field.schema())}("${this.mangle($field.name(), $schema.isError())}"${this.jsonFallback($field)});
    if (jsonObj != null) {
      return new ${this.javaType($field.schema())}(getJSONObject().${this.jsonAccessor($field.schema())}("${this.mangle($field.name(), $schema.isError())}"${this.jsonFallback($field)}));
    }
    return null;
  }
#elseif (${this.isMap($field.schema())})
  public ${this.javaType($field.schema())} ${this.generateGetMethod($schema, $field)}() {
    if (getJSONObject().isNull("${this.mangle($field.name(), $schema.isError())}")) return null;
    org.json.JSONObject object = getJSONObject().${this.jsonAccessor($field.schema())}("${this.mangle($field.name(), $schema.isError())}");
    return ${this.getBasePackage()}.JsonHelper.toMap(object);
  }
#else
  public ${this.javaType($field.schema())} ${this.generateGetMethod($schema, $field)}() {
    return getJSONObject().isNull("${this.mangle($field.name(), $schema.isError())}") ? null :
      getJSONObject().${this.jsonAccessor($field.schema())}("${this.mangle($field.name(), $schema.isError())}");
  }
#end

#end

#foreach ($field in $schema.getFields())
  /** Checks whether the '${this.mangle($field.name(), $schema.isError())}' field is set and is not null */
  public boolean ${this.generateIsNotNullMethod($schema, $field)}() {
    return !getJSONObject().isNull("${this.mangle($field.name(), $schema.isError())}");
  }

#if (${this.isArray($field.schema())} || ${this.isMap($field.schema())})
  /** Checks whether the '${this.mangle($field.name(), $schema.isError())}' field is set and is not null and is not empty */
  public boolean ${this.generateIsNotEmptyMethod($schema, $field)}() {
    return ${this.generateIsNotNullMethod($schema, $field)}() && !${this.generateGetMethod($schema, $field)}().isEmpty();
  }

#end
#end

#foreach ($field in $schema.getFields())
  /** Checks whether the '${this.mangle($field.name(), $schema.isError())}' field has been set, however the value could be null */
  public boolean ${this.generateHasMethod($schema, $field)}() {
    return getJSONObject().has("${this.mangle($field.name(), $schema.isError())}");
  }

#end

#if (${this.isCreateSetters()})
#foreach ($field in $schema.getFields())
  /**
   * Sets the field '${this.mangle($field.name(), $schema.isError())}'.
#if (${this.isArray($field.schema())})
   *
   * Nulls in the given List are skipped. List parameter is copied, so it will not reflect any changes, but objects inside it will.
#else
   *
   * The parameter is not copied so changes to it will be reflected in this instance and vice-versa.
#end
   */
  public ${this.mangle($schema.getName())} ${this.generateSetMethod($schema, $field)}(${this.javaType($field.schema())} ${this.mangle($field.name(), $schema.isError())}) {
    logChange("${this.mangle($field.name(), $schema.isError())}");

    try {
#if (${this.isArray($field.schema())})
      if (${this.mangle($field.name(), $schema.isError())} == null) {
        getJSONObject().put("${this.mangle($field.name(), $schema.isError())}", org.json.JSONObject.NULL);
        return this;
      }

      org.json.JSONArray array = new org.json.JSONArray();
      for (${this.javaType($field.schema().getElementType())} obj : ${this.mangle($field.name(), $schema.isError())}) {
        if (obj == null) {
          continue;
        }
#if (${this.isRecord($field.schema().getElementType())})
        array.put(obj.getJSONObject());
#else
        array.put(obj);
#end
      }

      org.json.JSONObject elementsContainer = new org.json.JSONObject();
      elementsContainer.put("elements", array);
      getJSONObject().put("${this.mangle($field.name(), $schema.isError())}", elementsContainer);
#else
#if (${this.isRecord($field.schema())})
      getJSONObject().put("${this.mangle($field.name(), $schema.isError())}",
          ${this.mangle($field.name(), $schema.isError())} == null ? org.json.JSONObject.NULL : ${this.mangle($field.name(), $schema.isError())}.getJSONObject());
#else
      getJSONObject().put("${this.mangle($field.name(), $schema.isError())}",
          ${this.mangle($field.name(), $schema.isError())} == null ? org.json.JSONObject.NULL : ${this.mangle($field.name(), $schema.isError())});
#end
#end
    } catch (org.json.JSONException e) {
      throw new java.lang.IllegalArgumentException(e);
    }
    return this;
  }

#end
#end

#foreach ($field in $schema.getFields())
  /** Clears the '${this.mangle($field.name(), $schema.isError())}' field, the 'has' method for this field will now return false */
  public void ${this.generateClearMethod($schema, $field)}() {
    unlogChange("${this.mangle($field.name(), $schema.isError())}");
    getJSONObject().remove("${this.mangle($field.name(), $schema.isError())}");
  }

#end

  private void logChange(java.lang.String field) {
    if (changeLog == null) {
      changeLog = new android.os.Bundle();
    }
    changeLog.putString(field, null);
  }

  private void unlogChange(java.lang.String field) {
    if (changeLog != null) {
      changeLog.remove(field);
    }
  }

  /**
   * Reset the log of changes made to this instance, calling copyChanges() after this would return an empty instance.
   */
  public void resetChangeLog() {
    changeLog = null;
  }

  /**
   * Create a copy of this instance that contains only fields that were set after the constructor was called.
   */
  public ${this.mangle($schema.getName())} copyChanges() {
    ${this.mangle($schema.getName())} copy = new ${this.mangle($schema.getName())}();
    copy.mergeChanges(this);
    copy.resetChangeLog();
    return copy;
  }

  /**
   * Copy all the changed fields from the given source to this instance.
   */
  public void mergeChanges(${this.mangle($schema.getName())} src) {
    if (src.changeLog != null) {
      try {
        // Make a copy of the source so the destination fields are copies
        org.json.JSONObject srcObj = new org.json.JSONObject(src.getJSONObject().toString());
        org.json.JSONObject dstObj = getJSONObject();
        for (java.lang.String field : src.changeLog.keySet()) {
          dstObj.put(field, srcObj.get(field));
          logChange(field);
        }
      } catch (org.json.JSONException e) {
        throw new java.lang.IllegalArgumentException(e);
      }
    }
  }


  /**
   * Gets a Bundle which can be used to get and set data attached to this instance. The attached Bundle will be
   * parcelled but not jsonified.
   */
  public android.os.Bundle getBundle() {
    if (bundle == null) {
      bundle = new android.os.Bundle();
    }
    return bundle;
  }

  @Override
  public String toString() {
    String json = jsonString != null ? jsonString : getJSONObject().toString();

    return "${this.mangle($schema.getName())}{" +
        "json='" + json + "'" +
        ", bundle=" + bundle +
        ", changeLog=" + changeLog +
        '}';
  }

  @Override
  public int describeContents() {
    return 0;
  }

  @Override
  public void writeToParcel(android.os.Parcel dest, int flags) {
    String json = jsonString != null ? jsonString : getJSONObject().toString();
    dest.writeString(json);
    dest.writeBundle(bundle);
    dest.writeBundle(changeLog);
  }

  public static final android.os.Parcelable.Creator<${this.mangle($schema.getName())}> CREATOR = new android.os.Parcelable.Creator<${this.mangle($schema.getName())}>() {
    @Override
    public ${this.mangle($schema.getName())} createFromParcel(android.os.Parcel in) {
      String json = in.readString();
      ${this.mangle($schema.getName())} instance = new ${this.mangle($schema.getName())}(json);
      instance.bundle = in.readBundle();
      instance.changeLog = in.readBundle();
      return instance;
    }

    @Override
    public ${this.mangle($schema.getName())}[] newArray(int size) {
      return new ${this.mangle($schema.getName())}[size];
    }
  };


  public interface Constraints {

#foreach ($field in $schema.getFields())
    public static final boolean ${this.mangle($field.name(), $schema.isError()).toUpperCase()}_IS_REQUIRED = ${this.isRequiredOnCreate($field)};
#if ($field.getJsonProp("length"))
    public static final long ${this.mangle($field.name(), $schema.isError()).toUpperCase()}_MAX_LEN = $field.getJsonProp("length").asLong();
#end
#if ($field.getJsonProp("min"))
    public static final long ${this.mangle($field.name(), $schema.isError()).toUpperCase()}_MIN = $field.getJsonProp("min").asLong();
#end
#if ($field.getJsonProp("max"))
    public static final long ${this.mangle($field.name(), $schema.isError()).toUpperCase()}_MAX = $field.getJsonProp("max").asLong();
#end

#end
  }

}
